# -*- coding: utf-8 -*-
"""KNN_classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MjIbqMWfVRlRN4Y30hE6cjL_IBf5DN0k
"""

from numpy import genfromtxt
data_path = 'knn/datasets/iris.csv'
my_data = genfromtxt(data_path, delimiter=',')

#print(my_data.shape)
#print(type(my_data))

my_list = my_data.tolist()

import random

shuffled_list = my_list.copy()
random.shuffle(shuffled_list)

train_set = []
val_set = []
test_set = []

# Splitting dataset into train, validation and test set

# checking if list is shuffled or not
# for i in range(5):
#   print(shuffled_list[i])
#   print(my_list[i])
#   print('-' * 30)

for s in shuffled_list:
  num = random.random()
  if num >= 0 and num <= 0.7:
    train_set.append(s)
  elif num > 0.7 and num <= 0.85:
    val_set.append(s)
  else:
    test_set.append(s)

print('train set length:', len(train_set))
print('val set length:', len(val_set))
print('test set length:', len(test_set))

# Implementing KNN Classification algorithm

import numpy as np

def majority_class(arr):
  '''
  arr is a 2D list where the first element is a list and the second element is a float denoting the distance
  '''
  class_list = []
  for element in arr:
    class_list.append(element[0][-1])
    # only taking the label/class values
  
  # print('class list:', class_list)
  class_set = set(class_list)
  return max(class_set, key = class_list.count)

# help(majority_class)

K = 10

# running algorithm on validation set

accuracy_counter = 0

for V in val_set:
  L = [] # list for storing distance
  v_point = np.array(V[:-1])
  # print('V as point:', v_point, 'V: ', V)
  
  for T in train_set:
    t_point = np.array(T[:-1])
    # print('T as point:', t_point)
    distance = (np.sum(np.square(v_point - t_point)))**0.5
    L.append([T, distance])

  L = sorted(L, key = lambda x:x[1])
  first_K = L[:K]
  # first_K = np.array(first_K)
  # print(first_K)
  # print('-' * 30)
  predicted_label = majority_class(first_K)
  # print('predicted label: ', predicted_label)
  if predicted_label == V[-1]:
    accuracy_counter += 1
  # else:
    # print('!!! ERROR !!!', '=> V:', V, ', predicted label:', predicted_label, '\n')


accuracy = (accuracy_counter / len(val_set)) * 100

print()
print('In validation set:')
print('Correct predictions: ', accuracy_counter, 'out of', len(val_set))
print('Accuracy level: ', str(round(accuracy, 3)) + '%')

# running algorithm on test set

accuracy_counter = 0

for V in test_set:
  L = [] # list for storing distance
  v_point = np.array(V[:-1])
  # print('V as point:', v_point, 'V: ', V)
  
  for T in train_set:
    t_point = np.array(T[:-1])
    # print('T as point:', t_point)
    distance = (np.sum(np.square(v_point - t_point)))**0.5
    L.append([T, distance])

  L = sorted(L, key = lambda x:x[1])
  first_K = L[:K]
  # first_K = np.array(first_K)
  # print(first_K)
  # print('-' * 30)
  predicted_label = majority_class(first_K)
  # print('predicted label: ', predicted_label)
  if predicted_label == V[-1]:
    accuracy_counter += 1
  # else:
    # print('!!! ERROR !!!', '=> V:', V, ', predicted label:', predicted_label, '\n')


accuracy = (accuracy_counter / len(test_set)) * 100

print()
print('In test set:')
print('Correct predictions: ', accuracy_counter, 'out of', len(test_set))
print('Accuracy level: ', str(round(accuracy, 3)) + '%')